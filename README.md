Interview Questions and Answers Based on Redux Toolkit
General Questions

1. What is createSlice in Redux Toolkit?

Answer: createSlice is a utility in Redux Toolkit that simplifies the creation of Redux reducers and actions. It takes an initial state, reducer logic, and automatically generates action creators and action types.

2. What is createAsyncThunk, and why is it used?

Answer: createAsyncThunk is a utility for handling asynchronous logic in Redux Toolkit. It abstracts the lifecycle of async operations (pending, fulfilled, and rejected) and is commonly used for actions like fetching data from APIs.

3. What is the difference between reducers and extraReducers in a slice?

Answer:
reducers: Used for handling synchronous actions defined in the same slice.
extraReducers: Used to handle actions from outside the slice, such as actions created using createAsyncThunk.

4. How is Redux Toolkit different from traditional Redux?

Answer: Redux Toolkit reduces boilerplate code and simplifies common tasks like state management, async handling, and middleware configuration. It comes with utilities like createSlice, createAsyncThunk, and configureStore.

Scenario-Based Questions

5. In a slice, why do we use extraReducers with createAsyncThunk?

Answer: extraReducers is used to handle the action lifecycle (pending, fulfilled, rejected) of createAsyncThunk. It allows us to update the state based on the outcome of the asynchronous operation, such as adding fetched data to the state or handling errors.

6. How would you manage a situation where an API fetch fails using createAsyncThunk?

Answer:
Use the rejected action generated by createAsyncThunk.
In extraReducers, handle the error by updating the state (e.g., setting loading to 'failed' and storing the error message).
Example:


builder.addCase(fetchUserById.rejected, (state, action) => {
    state.loading = 'failed';
    state.error = action.error.message;
});


7. How would you implement optimistic updates using Redux Toolkit?

Answer: Optimistic updates can be implemented by:
Immediately updating the state with the presumed success data.
Rolling back the state if the operation fails.
Example:


builder.addCase(updateUser.fulfilled, (state, action) => {
    const index = state.entities.findIndex(user => user.id === action.payload.id);
    if (index !== -1) {
        state.entities[index] = action.payload;
    }
});
builder.addCase(updateUser.rejected, (state, action) => {
    // Revert state if necessary
});


Code-Specific Questions

8. How do you handle the loading state in createAsyncThunk?

Answer: The createAsyncThunk automatically provides pending, fulfilled, and rejected actions. You can handle these actions in extraReducers to update the loading state accordingly.
Example:


builder
    .addCase(fetchUserById.pending, (state) => {
        state.loading = 'pending';
    })
    .addCase(fetchUserById.fulfilled, (state, action) => {
        state.loading = 'succeeded';
        state.entities.push(action.payload);
    })
    .addCase(fetchUserById.rejected, (state) => {
        state.loading = 'failed';
    });


Practical Questions

9. How would you delete a user from the state using Redux Toolkit?
Answer:

removeUser: (state, action) => {
    state.user = state.user.filter((user) => user.id !== action.payload);
};
10. How can you handle multiple API calls in a single slice?
Answer: You can define multiple createAsyncThunk functions for each API call and handle their actions in extraReducers. Each thunk can have its own logic for fetching data and updating the state.
Example:


const fetchUsers = createAsyncThunk('users/fetch', async () => { /* API call */ });
const deleteUser = createAsyncThunk('users/delete', async (id) => { /* API call */ });

const userSlice = createSlice({
    name: 'users',
    initialState,
    reducers: {},
    extraReducers: (builder) => {
        builder
            .addCase(fetchUsers.fulfilled, (state, action) => { state.entities = action.payload; })
            .addCase(deleteUser.fulfilled, (state, action) => {
                state.entities = state.entities.filter(user => user.id !== action.payload);
            });
    },
});

Comparison-Based Questions

11. When would you use createAsyncThunk over basic reducers?
Answer: Use createAsyncThunk when handling asynchronous actions such as API calls. Basic reducers are used for synchronous logic that doesn't involve side effects.
How is error handling different between createAsyncThunk and basic reducers?
Answer:
In createAsyncThunk, errors are handled through the rejected action in the lifecycle.
In basic reducers, error handling must be done manually within the action logic or UI components.
